---
title: 엔터테인먼트관리시스템
date: 2025-05-22
categories: [프로젝트]
tags: [프로젝트, 엔터테인먼트관리시스템, EMS, 커뮤니티]
render_with_liquid: true
---

> ## 프로젝트명


<br>

**프로젝트명 :** &nbsp; FannectCMS  
**서비스명 :** &nbsp; oHoT (hot한 사람들의 모임)  

**FannectCMS**는 팬과 아티스트 간의 소통을 중심으로 설계된 **엔터테인먼트 전용 커뮤니티 관리 시스템(Community Management System)**입니다.  

팬은 아티스트의 콘텐츠에 반응하고 게시글을 작성하며, 아티스트는 팬들과의 소통 공간을 관리할 수 있습니다. **단순한 커뮤니티를 넘어, 팬과 아티스트를 연결하고, 관리하며, 함께 성장할 수 있는 플랫폼을 목표로 개발하였습니다**. 해당 시스템은 서비스명 “oHoT” 하에 제공되며, 트렌디하고 활발한 팬 커뮤니티를 지향합니다.

<br>

---
> ## 프로젝트 개요  

**프로젝트 일정 (2025.03.28 ~ 2025.05.07)**

![프로젝트일정](/assets/img/pro/ems/프로젝트일정.png "프로젝트 일정")

<br>

**참여 인원**  
총 7인 (팀 프로젝트)  
- **프로젝트 리더 (PL) – 1인 (본인)**
- 품질 테스트 담당 (QA) – 1인  
- 기술 지원 담당 (TA) – 1인  
- 데이터 설계 및 분석 (DA) – 2인  
- 사용자 피드백 및 검증 (UA) – 1인  
- 아티스트 콘텐츠 관리 (AA) – 1인  
  
<br>

---
> ## 프로젝트 내용

## - 주요 기능 요약

![주요기능](/assets/img/pro/ems/주요기능1.png "주요기능1")

![주요기능](/assets/img/pro/ems/주요기능2.png "주요기능2")


## - 주요 화면

**1. 메인 화면**

가입한 커뮤니티 목록과 판매 중인 굿즈를 한눈에 확인할 수 있습니다.  
로케일 설정을 통해 다양한 언어로 서비스를 이용할 수 있습니다.

![주요화면](/assets/img/pro/ems/메인화면.gif "메인화면")
_메인화면.gif_

<br>

**2. 커뮤니티 화면**

팬과 아티스트가 자유롭게 소통할 수 있는 커뮤니티 공간으로, 게시글 작성, 댓글, 팔로우 기능 등을 제공합니다.  
또한, 관리자가 등록한 공식 미디어 콘텐츠도 감상할 수 있습니다.

![주요화면](/assets/img/pro/ems/커뮤니티화면.gif "커뮤니티화면")
_커뮤니티화면.gif_

<br>

**3. 라이브 영상 시청 페이지**  

실시간으로 방송 중인 아티스트의 라이브를 시청할 수 있으며, 채팅 화면을 통해 다른 팬들과 소통할 수 있습니다.

![주요화면](/assets/img/pro/ems/라이브페이지.png "라이브페이지")
_라이브 방송 화면 (방송자 관점)_

<br>

**4. 아티스트별 굿즈샵 화면**

아티스트별로 운영되는 굿즈샵에서 해당 아티스트의 상품만 확인하고 구매할 수 있습니다.

![주요화면](/assets/img/pro/ems/그룹별굿즈샵.png "그룹별굿즈샵")
_아티스트별 굿즈샵 화면_

<br>

**5. 티켓 예매 화면**

공연 정보를 확인하고, 원하는 좌석을 선택해 티켓팅할 수 있는 예매 전용 화면입니다.

![주요화면](/assets/img/pro/ems/티켓팅.png "티켓팅")
_티켓팅 중 좌석 선택 화면_

<br>

## - 담당 역할 및 기능구현

**1. 담당 역할**

**프로젝트 리더(PL)**로서 전체 일정을 총괄하며 팀을 이끌었고, **스크럼 회의를 통해 진행 상황을 주기적으로 점검**하며 이슈 발생 시 즉각적으로 조율해 **프로젝트가 일정에 맞춰 원활히 진행**될 수 있도록 관리했습니다.
또한 **회의록 작성을 팀원 간 순환제로 운영**하여 문서화 습관을 정착시키고, 협업 문화를 강화하는 데 기여했습니다.

<br>

**2. 구현한 기능 목차**

**[ 공통 ]**  
 **1) Spring Security 6.2.2 설정 및 통합 로그인 처리**
 - [다중필터 적용](#multi-filter)
 - [USERS 뷰 통합 관리](#users-view)  
 <br>

**[ 회원 화면 ]**  
 **1) SNS 및 일반 회원가입 / 로그인 기능 구현**
 - [사용자 인증 정보 로딩 처리](#authentication)
 - [로그인 처리](#login)
 - [로그아웃 처리](#logout)
 - [예외 처리](#exception)
 - [BCryptPasswordEncoder 암호화](#bcrypt)
 - [SMTP 인증번호 이메일 발송](#smtp)
 - [Spring Security 의 OAuth2 Client 설정(KAKAO API)](#oauth2)

**2) 메인페이지**
 - [인증 / 권한에 따른 UI 구성](#auth-ui)
 - [검색 기능](#search-function)
 - [스프링 메시지 기반 다국어처리](#message)
 - [번역기능 (Cloud Translation API)](#translation)
 
**3) 마이페이지**
 - [회원 정보 조회 및 수정](#my-page)

**4) 아티스트 소개 페이지**
 - [Spotify API 를 통한 1분 미리 듣기 구현](#spotify)

**5) 문의 글 화면**
 - [ckEditor 활용(이미지 업로드 구현)](#ckeditor)
 - [XSS 공격 방어](#xss)
 - [비밀번호 설정 기능](#pswd-config)  
 <br>

**[ 관리자 화면 ]**  
**1) 문의 글 관리 화면**
 - [비동기 기반 게시글 목록 조회 및 커스텀 페이지네이션 구현](#ajax)
 - [문의글 / 답글 관리](#crud)
 - [첨부파일 다운로드](#download)  
 <br>

**[ 직원 화면 ]**  
**1) Full Calendar 기반 일정 관리 기능 구현**
 - [사내 일정 통합 관리](#calenear-crud) → 부서 일정은 권한 보유자만 CRUD 가능  

<br>

**3. 기능구현 상세설명**

### Spring Security 6.2.2 설정 및 통합 로그인 처리

<a name="multi-filter"></a>

**1) 다중필터 적용**

**@Order(1) - 관리자 SecurityFilterChain**

```java
@Bean
@Order(1)
protected SecurityFilterChain adminSecurity(HttpSecurity http) throws Exception {
    return http
        .securityMatcher("/admin/**")
        .csrf(csrf -> csrf.disable()).httpBasic(hbasic -> hbasic.disable())
        .headers(config -> config.frameOptions(customizer -> customizer.sameOrigin()))
        .authorizeHttpRequests(authz -> authz
                .dispatcherTypeMatchers(DispatcherType.FORWARD, DispatcherType.ASYNC).permitAll()
                .requestMatchers("/admin/login").anonymous()
                .requestMatchers("/emp/**").hasAnyRole("EMP", "ADMIN")
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated())
        .formLogin(formLogin -> formLogin.loginPage("/admin/login")
                .successHandler(customLoginSuccessHandler)
                .failureHandler(customLoginFailureHandler))
        .logout(logout -> logout
                .logoutUrl("/admin/logout")
                .logoutSuccessHandler(customLogoutSuccessHandler)
                .invalidateHttpSession(true) // 세션 무효화
                .deleteCookies("JSESSIONID")
            )
        .sessionManagement(session -> session.maximumSessions(1))
        .exceptionHandling(ex ->
            ex.authenticationEntryPoint(new CustomAuthenticationEntryPoint())) // 인증 안 됨 -> 로그인 요청
        .build();
}
```  
  
**@Order(2) - 직원 SecurityFilterChain**
```java
@Bean
@Order(2)
protected SecurityFilterChain empSecurity(HttpSecurity http) throws Exception {
    return http
        .securityMatcher("/emp/**")
        .csrf(csrf -> csrf.disable()).httpBasic(hbasic -> hbasic.disable())
        .headers(config -> config.frameOptions(customizer -> customizer.sameOrigin()))
        .authorizeHttpRequests(authz -> authz
                .dispatcherTypeMatchers(DispatcherType.FORWARD, DispatcherType.ASYNC).permitAll()
                .requestMatchers("/emp/login").anonymous()
                .requestMatchers("/emp/**").hasAnyRole("EMP", "ADMIN")
                .anyRequest().authenticated())
        .formLogin(formLogin -> formLogin.loginPage("/emp/login")
                .successHandler(customLoginSuccessHandler)
                .failureHandler(customLoginFailureHandler))
        .logout(logout -> logout
                .logoutUrl("/emp/logout")
                .logoutSuccessHandler(customLogoutSuccessHandler)
                .invalidateHttpSession(true)
                .deleteCookies("JSESSIONID")
                )
        .sessionManagement(session -> session.maximumSessions(1))
        .exceptionHandling(ex ->
            ex.authenticationEntryPoint(new CustomAuthenticationEntryPoint()))
        .build();
}
```

**@Order(3) - 일반 회원 SecurityFilterChain**
```java
@Bean
@Order(3)
protected SecurityFilterChain memberSecurity(HttpSecurity http) throws Exception {
    return http.csrf(csrf -> csrf.disable()).httpBasic(hbasic -> hbasic.disable())
        .headers(config -> config.frameOptions(customizer -> customizer.sameOrigin()))
        .authorizeHttpRequests(authz -> authz
            .dispatcherTypeMatchers(DispatcherType.FORWARD, DispatcherType.ASYNC).permitAll()
            .requestMatchers("/**", "/oho/inquiryPost/**", "/ckEditor/**").permitAll()
            .requestMatchers("/oho/community/**").hasAnyRole("MEM", "ART", "ADMIN")
            .requestMatchers("/oho/mypage/**").hasAnyRole("MEM", "ART", "ADMIN")
            .anyRequest().authenticated()
        )
        .formLogin(formLogin -> formLogin.loginPage("/login")
            .successHandler(customLoginSuccessHandler)
            .failureHandler(customLoginFailureHandler)
        )
        .oauth2Login(oauth2 -> oauth2
            .loginPage("/login")
            .userInfoEndpoint(userInfo -> userInfo
                .userService(customOAuth2UserService)
            )
            .successHandler(auth2SuccessHandler)
            .failureHandler(oAuth2FailureHandler)
        )
        .logout(logout -> logout
            .logoutUrl("/logout")
            .logoutSuccessHandler(customLogoutSuccessHandler)
            .invalidateHttpSession(true)
            .deleteCookies("JSESSIONID")
        )
        .sessionManagement(session -> session.maximumSessions(1))
        .exceptionHandling(ex ->
            ex.authenticationEntryPoint(new CustomAuthenticationEntryPoint())
        )
        .build();
}
```

&nbsp;&nbsp;**Spring Security 6.2.2를 기반**으로, `@Order`와 `SecurityMatcher`를 활용하여 **관리자, 직원, 일반 회원의 역할(Role)에 따라 다중** `SecurityFilterChain`**을 구성**하였습니다.  
&nbsp;&nbsp;URL 패턴별 접근 권한을 정밀하게 제어하고, 각 체인에 커스텀 로그인/로그아웃 핸들러, OAuth2 인증 처리, 예외 응답 로직 등을 분리 적용하여 사용자 유형별 보안 흐름을 체계적으로 구축하였습니다.  

<br>

<a name="users-view"></a>

**2) USERS 뷰 통합 관리**  

&nbsp;&nbsp;직원(EMPLOYEE)과 회원(MEMBER)은 서로 독립된 엔터티로 관리되기 때문에, 로그인 인증을 위해 **별도의 USERS 테이블을 생성할 경우 데이터 중복 및 동기화 이슈가 발생**할 수 있습니다.  

&nbsp;&nbsp;이를 방지하고, 로그인 시 공통으로 요구되는 필드(ID, 비밀번호, 권한 등)에 대해 **일관된 접근 방식을 제공**하기 위해 USERS VIEW를 생성하였습니다.  

&nbsp;&nbsp;**VIEW는 원본 테이블의 데이터를 그대로 참조하므로 항상 최신 정보를 반영**할 수 있고, 테이블 구조를 변경하지 않고도 인증에 필요한 정보를 가공해 제공할 수 있어 유지보수와 보안 측면에서도 효율적인 선택입니다.  
<br>

```sql
CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "TEAM2_202410F"."USERS" ("USER_NO", "USER_MAIL", "USER_PSWD", "ENABLED", "SNS_YN") AS 
  SELECT
        E.EMP_NO AS USER_NO,
        E.EMP_EML_ADDR AS USER_MAIL,
        E.EMP_PSWD AS USER_PSWD,
        E.ENABLED AS ENABLED,
        E.SNS_EMP_YN AS SNS_YN
        FROM EMPLOYEE E
    
    UNION ALL
    
    SELECT
        M.MEM_NO AS USER_NO,
        M.MEM_EMAIL AS USER_MAIL,
        M.MEM_PSWD AS USER_PSWD,
        M.ENABLED AS ENABLED,
        M.SNS_MEM_YN AS SNS_YN
    FROM MEMBER M
```

&nbsp;&nbsp;해당 VIEW는 Spring Security에서 요구하는 사용자 정보 형식에 맞게 구성되어, 사용자 유형(직원/회원)에 관계없이 **동일한 인증 구조를 적용**할 수 있도록 도와줍니다. 이로 인해 실제 테이블 구조를 변경하지 않고도 사용자 정보를 일관되게 제공할 수 있었고, **인증 및 권한 처리 로직을 단순화**할 수 있었습니다.  
&nbsp;&nbsp;결과적으로, 권한 분기 처리의 유지보수가 쉬워졌으며, 사용자 유형이 추가되더라도 구조 확장이 유연한 형태로 시스템을 구성할 수 있었습니다.
<br>

---

### SNS 및 일반 회원가입 / 로그인 기능 구현

<a name="authentication"></a>

**1) 사용자 인증 정보 로딩 처리**

**1-1. 일반 로그인**
```java
@Slf4j
@Service
public class UserDetailsServiceImpl implements UserDetailsService{

  @Autowired
  UsersMapper usersMapper;
  @Autowired
  MemberMapper memberMapper;
  @Autowired
  UserStatusService userStatusService;
    
  @Transactional
  @Override
  public UserDetails loadUserByUsername(String userMail) throws UsernameNotFoundException {
    // 요청 URL
    HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
    String requestURL = request.getRequestURI();
    
    UsersVO usersVO = usersMapper.findByEmail(userMail);
    
    if(usersVO == null) {
        throw new UsernameNotFoundException("EMAIL_NOT_FOUND");
    }
    // 로그인 경로별 Role 제한
    List<UserAuthVO> roles = usersVO.getUserAuthList(); // ex) ROLE_MEM, ROLE_ART, ROLE_ADMIN, ROLE_EMP

    // 관리자 로그인페이지일 경우
    if (requestURL.startsWith("/admin") || requestURL.startsWith("/emp")) {
        if (roles.stream().anyMatch(auth -> auth.getAuthNm().equals("ROLE_MEM") || auth.getAuthNm().equals("ROLE_ART"))) {
            throw new UsernameNotFoundException("EMAIL_NOT_FOUND");
        }
        EmployeeVO empVO = usersMapper.findByEmailAdmin(userMail);
        if(empVO != null) {
            usersVO.setEmployeeVO(empVO);
        }
    }
    
    // 일반 로그인 페이지일 경우
    if (requestURL.startsWith("/login")) {
        // 회원 상태와 멤버십 만료 체크
        userStatusService.checkAndUpdateMemberStatus(usersVO);
        
        String snsYn = usersVO.getSnsYn();
        // 간편가입 회원이면 로그인 차단
        if ("Y".equals(snsYn)) {
            throw new UsernameNotFoundException("SNS_MEMBER");
        }
        if (roles.stream().anyMatch(auth -> auth.getAuthNm().equals("ROLE_ADMIN") || auth.getAuthNm().equals("ROLE_EMP"))) {
            throw new UsernameNotFoundException("EMAIL_NOT_FOUND");
        }
    }
    // 서비스 회원가입자일 경우 -> 로그인 성공
    return new CustomUser(usersVO);
  }
}
```

- `UserDetailsService`를 커스터마이징하여 일반 로그인 시 사용자 인증을 처리했습니다.
- 로그인 요청 경로를 기반으로 사용자 권한을 검증하며, 권한 미부여 시 로그인 차단 예외를 발생시켜 보안을 강화하였습니다.
- `/login` 경로에서는 **SNS 간편가입 사용자 차단, 탈퇴/정지 여부 확인, 멤버십 만료 처리**를 위해 `UserStatusService`를 호출해 회원 상태를 점검합니다.
- 인증이 완료된 사용자는 `CustomUser` 객체로 감싸 반환하여 *Spring Security*가 인증 정보를 관리하도록 처리하였습니다.

**➡️ 권한 검증 + 사용자 상태 검증 + `CustomUser` 생성의 3단계 흐름으로, 역할 기반 인증과 회원 관리 정책을 모두 반영한 설계입니다.**  

<br>
<!-- &nbsp;&nbsp;`UserDetailsService`를 커스터마이징하여, 일반 로그인 요청 시 사용자 정보를 인증 처리하는 로직을 구현하였습니다. 로그인 요청 경로를 기준으로 사용자 권한을 검증하고, 해당 권한이 없는 사용자의 경우 로그인 차단 예외를 발생시켜 보안을 강화했습니다.
&nbsp;&nbsp;일반 로그인(`/login`) 경로에서는 **SNS 간편가입 사용자 차단, 탈퇴/정지 여부 확인, 멤버십 만료 처리** 등을 위해 `UserStatusService`를 호출하여 회원 상태를 검사하고, 필요 시 로그인 차단 또는 자동 상태 복원/업데이트를 수행합니다.
&nbsp;&nbsp;
&nbsp;&nbsp;**권한 검증 + 사용자 상태 검증 + CustomUser 생성의 3단계 흐름으로, 역할 기반 인증과 회원 관리 정책을 모두 반영한 설계입니다.** -->

**1-2. SNS 로그인**

![기능구현](/assets/img/pro/ems/my-part/카카오로그인.gif "카카오로그인")
<center><small>카카오로그인.gif</small></center>  
<br>

```java
@Slf4j
@Service
public class CustomOAuth2UserServiceImpl implements OAuth2UserService<OAuth2UserRequest, OAuth2User>{

    @Autowired
    private UsersMapper usersMapper;
    @Autowired
    UserStatusService userStatusService;
     
    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {
    OAuth2User oAuth2User = new DefaultOAuth2UserService().loadUser(userRequest);
        
    Map<String, Object> attributes = oAuth2User.getAttributes();
        
    Object kakaoAccountObj = attributes.get("kakao_account");
    Map<String, Object> kakaoAccount = new HashMap<>();
    if (kakaoAccountObj instanceof Map) {
      Map<?, ?> tempMap = (Map<?, ?>) kakaoAccountObj;
      for (Map.Entry<?, ?> entry : tempMap.entrySet()) {
          if (entry.getKey() instanceof String) {
            kakaoAccount.put((String) entry.getKey(), entry.getValue());
          }
        }
    }
    String email = (String) kakaoAccount.get("email");
        UsersVO usersVO = this.usersMapper.findByEmail(email);
        
        if(usersVO != null) {// 회원 상태와 멤버십 만료 체크
        userStatusService.checkAndUpdateMemberStatus(usersVO);
        }else { // 신규회원
            ServletRequestAttributes attr = (ServletRequestAttributes) RequestContextHolder.currentRequestAttributes();
            HttpServletRequest request = attr.getRequest();
            request.getSession().setAttribute("KAKAO_EMAIL", email);

            throw new OAuth2AuthenticationException("UNREGISTERED_USER");
        }
      return new CustomUser(usersVO);
  }
}
```
- SNS(카카오) 로그인 처리를 위해 `OAuth2UserService`를 구현하였습니다.
- 인증 후 사용자 이메일 기반으로 등록 여부를 확인합니다.
  - 기존 사용자: `UserStatusService`로 상태 검증
  - 신규 사용자: 이메일 세션 저장 → 예외 발생 (`UNREGISTERED_USER`) → 가입 페이지 이동
- 로그인 성공 시 `CustomUser` 객체를 반환하여 *Spring Security* 인증 컨텍스트에 등록됩니다.

**➡️ 일반 로그인과 동일한 상태 검증 로직을 공유함으로써, 인증 방식에 상관없이 일관된 보안성과 사용자 흐름을 유지했습니다.**  
<br>
<!-- 
&nbsp;&nbsp;SNS(카카오) 로그인 처리를 위해 `OAuth2UserService`를 구현하였습니다. 카카오 인증 서버로부터 받은 사용자 정보에서 이메일을 추출하고, 이를 기반으로 DB에 등록된 사용자 여부를 판단합니다.
&nbsp;&nbsp;기존 사용자일 경우 `UserStatusService`를 호출하여 **탈퇴, 정지, 멤버십 상태를 동일하게 검증**하며,
신규 사용자일 경우 이메일을 세션에 저장한 뒤, `OAuth2AuthenticationException("UNREGISTERED_ USER")`를 발생시켜 **회원가입 화면으로 전환**되도록 처리하였습니다.
&nbsp;&nbsp;로그인 성공 시 `CustomUser` 객체를 반환하여 *Spring Security* 인증 컨텍스트에 등록됩니다.
&nbsp;&nbsp;**일반 로그인과 동일한 상태 검증 로직을 공유함으로써, 인증 방식에 상관없이 일관된 보안성과 사용자 흐름을 유지했습니다.** -->

**1-3. 회원 상태 확인 및 업데이트**

```java
@Service
public class UserStatusService {
    
    @Autowired
    private UsersMapper usersMapper;
    
    public void checkAndUpdateMemberStatus(UsersVO usersVO) {
        MemberVO memVO = usersMapper.findByEmailMember(usersVO.getUserMail());
        
        if(memVO != null) {
            usersVO.setMemberVO(memVO);
        
            // 탈퇴한 회원 체크
            if(memVO.getMemDelYn().equals("Y")) {
                throw new UsernameNotFoundException("DELETED_MEMBER");
            }
        
            int memNo = (int)usersVO.getUserNo();
        
            // 활동정지된 회원 체크
            if(usersVO.getMemberVO().getMemStatSecCodeNo().equals("004")) { // 004 = 활동정지
                // 활동정지 종료일 여부 체크
                ReportmanageVO reportVO = this.usersMapper.getMemStopYN(memNo);
                if(reportVO != null) { // 종료일이 지나지 않았을 경우
                  throw new UsernameNotFoundException("STOP_MEMBER, EndDate=" + reportVO.getReportEndDt());
                }else { // 종료일이 지났을 경우
                  // 회원 상태 업데이트 (정지->활동)
                  this.usersMapper.updateMemStatus(memNo);
                }
            }
            // 멤버십 유효기간이 지난 커뮤니티 체크
            List<CommunityProfileVO> communityProfileVOList = this.usersMapper.selectExpMemberShipList(memNo);
        
            if(!communityProfileVOList.isEmpty()) {
                // 유효기간이 지난 커뮤니티 리스트
                for(CommunityProfileVO communityProfileVO : communityProfileVOList) {
                  int comProfileNo = communityProfileVO.getComProfileNo();
                  // 커뮤니티 멤버십 해제
                  this.usersMapper.expMemberShip(comProfileNo);
                }
            }
        }
    }
}
```
- 로그인 시 `탈퇴/정지/SNS간편가입/멤버십 만료` 상태를 점검합니다.
- 예외 발생 또는 자동 상태 업데이트를 처리합니다.
- 인증 로직과 분리하여 **유지보수성과 재사용성을 높인 구조로 설계**하였습니다.

**➡️ 로그인 시 실시간으로 회원 상태를 점검 및 자동 업데이트함으로써 관리자의 개입 없이도 최신 상태를 유지할 수 있도록 구현했습니다.**  
<br>
<!-- &nbsp;&nbsp;로그인 시 호출되는 회원 상태 검증 전담 서비스입니다. **탈퇴, 정지, 간편가입 여부 및 멤버십 만료 상태를 확인**하고, 필요한 경우 예외를 발생시키거나 상태를 자동으로 업데이트하도록 구성하였습니다.
&nbsp;&nbsp;이 서비스는 일반 로그인(`UserDetailsServiceImpl`)과 SNS 로그인(`CustomOAuth2UserService Impl`) 양쪽에서 공통으로 사용되며,
인증 흐름과 사용자 상태 관리의 책임을 분리하여 **유지보수성과 재사용성을 높인 구조로 설계**하였습니다.
&nbsp;&nbsp;**인증 처리와 상태 관리를 분리하여 관심사를 분리**하였고, 로그인 시 실시간으로 회원 상태를 점검 및 자동 업데이트함으로써 관리자의 개입 없이도 최신 상태를 유지할 수 있도록 구현했습니다. -->

<a name="login"></a>

**2) 로그인 처리**

**2-1. 로그인 성공 시 처리**

```java
@Slf4j
@Component
public class CustomLoginSuccessHandler implements AuthenticationSuccessHandler{
    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
            Authentication authentication) throws IOException, ServletException {

        // 로그인한 사용자 정보 가져오기
        CustomUser customUser = (CustomUser) authentication.getPrincipal();

        // 사용하던 페이지로 리다이렉트
        String redirectURL = request.getParameter("redirectURL");
        
        switch (redirectURL) {
            case "/admin/login":
                redirectURL = "/admin/home";
                break;
            case "/emp/login":
                redirectURL = "/emp/home";
                break;
            case "/" : 
            case ""  :
            case "/login":
                redirectURL = "/oho";
                break;
        }
            response.sendRedirect(redirectURL);
    }
}
```
- 로그인 요청 시 redirectURL 파라미터를 통해 로그인 요청 경로를 전달받습니다.
- 로그인 경로(`redirectURL`)에 따라 리다이렉트 URL을 분기 처리했습니다.
  - `/admin/login` → `/admin/home`
  - `/emp/login` → `/emp/home`
  - `/login` → `/oho`

**➡️ 이를 통해 로그인 흐름을 권한별로 분리하면서도, 모든 로직을 하나의 핸들러에 통합하여 유지보수성과 확장성을 높였습니다.**  
<br>
<!-- &nbsp;&nbsp;로그인 성공 후 사용자 권한에 따라 각 전용 페이지로 리다이렉트되도록 `Authentication SuccessHandler`를 커스터마이징하였습니다.
&nbsp;&nbsp;로그인 요청 시 사용자가 입력한 로그인 경로를 `redirectURL` 파라미터로 함께 전달받고,
&nbsp;&nbsp;로그인 성공 시 해당 경로를 기준으로
`/admin/login` → `/admin/home`,
`/emp/login` → `/emp/home`,
`/login` → `/oho`로 분기되도록 구현하였습니다.
&nbsp;&nbsp;이를 통해 **로그인 흐름을 권한별로 분리**하면서도, 모든 로직을 하나의 핸들러에 통합하여 **유지보수성과 확장성**을 높였습니다. -->

**2-2. 로그인 실패 시 처리**

```java
@Slf4j
@Component
public class CustomLoginFailureHandler implements AuthenticationFailureHandler{
    
    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
                                        AuthenticationException exception) throws IOException, ServletException {

        String errorMessage;

        if (exception instanceof UsernameNotFoundException) {
            if ("EMAIL_NOT_FOUND".equals(exception.getMessage())) {
                errorMessage = "존재하지 않은 계정입니다. 새 계정을 생성해주세요.";
            } else if ("SNS_MEMBER".equals(exception.getMessage())) {
                errorMessage = "간편로그인 회원입니다. 간편 로그인으로 시도해 주세요.";
            }else if (exception.getMessage().equals("DELETED_MEMBER")) {
                errorMessage = "탈퇴된 계정입니다.";
            }else if(exception.getMessage().startsWith("STOP_MEMBER")) {
                String[] parts = exception.getMessage().split("=");
                String date = parts[1].trim();
                errorMessage = date + "까지 정지된 계정입니다.";
            }else {
                errorMessage = "비밀번호가 일치하지 않습니다. 다시 확인해주세요.";
            }
        } else if (exception instanceof BadCredentialsException) {
            errorMessage = "비밀번호가 일치하지 않습니다. 다시 확인해주세요.";
        } else {
            errorMessage = "로그인에 실패했습니다.";
        }
        // 리퍼러를 기준으로 실패 URL 설정
        String referer = request.getHeader("Referer");
        
        String redirectPath = "/login"; // 기본 경로
        
        if (referer != null) {
            if (referer.contains("/admin/login")) {
                redirectPath = "/admin/login";
            } else if (referer.contains("/emp/login")) {
                redirectPath = "/emp/login";
            }
        }
        response.sendRedirect(redirectPath + "?error=" + URLEncoder.encode(errorMessage, "UTF-8"));
    }
}
```
- 예외 메시지 기반으로 실패 유형을 분기 처리했습니다.
<!-- &nbsp;&nbsp;로그인 실패 시의 사용자 경험(UX)을 개선하기 위해 `AuthenticationFailureHandler`를 커스터마이징하였습니다.
&nbsp;&nbsp;예외 메시지를 기반으로 인증 실패 유형을 분기하여 상황별 맞춤 에러 메시지를 제공하고, 요청의 `Referer` 헤더를 활용하여 로그인 경로에 따라 다시 적절한 로그인 페이지로 리다이렉트되도록 구성하였습니다. -->

|인증 실패 유형|설명|
|:----------:|:-:|
| EMAIL_NOT_FOUND | 존재하지 않는 계정 |
| SNS_MEMBER | 간편 로그인 유도 |
| DELETED_MEMBER | 탈퇴 회원 |
| STOP_MEMBER=날짜 | 정지된 계정 |
| BadCredentialsException | 비밀번호 불일치 |

<small>표 1. 인증 실패 유형에 따른 메시지 설명</small>

- 요청의 `Referer` 헤더를 활용하여 로그인 경로에 따라 다시 적절한 로그인 페이지로 리다이렉트되도록 구성하였습니다.
- 에러 메시지는 `URLEncoder` 적용하여, 한글 인코딩 문제를 해결합니다.

**➡️ 이러한 구조는 단순한 실패 메시지 출력에 그치지 않고, 사용자 상태에 맞춘 정교한 실패 처리를 통해 UX와 인증 흐름 안정성 모두를 강화한 사례입니다.**  
<br>
<!-- &nbsp;&nbsp;이러한 구조는 단순한 실패 메시지 출력에 그치지 않고, **사용자 상태에 맞춘 정교한 실패 처리를 통해 UX와 인증 흐름 안정성 모두를 강화한 사례**입니다.
&nbsp;&nbsp;한글 메시지 인코딩 시 `URLEncoder`를 적용하여 깨짐 없이 에러 메시지를 안전하게 전달하도록 처리한 점도 보안 및 사용자 친화 측면에서 고려된 부분입니다. -->

<a name="logout"></a>

**3) 로그아웃 처리**

**3-1. 로그아웃 성공 시 처리**

```java
@Slf4j
@Component
public class CustomLogoutSuccessHandler implements LogoutSuccessHandler{

  @Override
  public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication)
            throws IOException, ServletException {
    // 요청 URI
    String requestURI = request.getRequestURI();

    String redirectPath = "";
        
    if (requestURI.startsWith("/oho")) {
        redirectPath = "/oho";
    } else if (requestURI.startsWith("/shop")) {
        redirectPath = "/shop/home";
    } else if (requestURI.startsWith("/admin")) {
        redirectPath = "/admin/login";
    } else if (requestURI.startsWith("/emp")) {
        redirectPath = "/emp/login";
    } else {
        redirectPath = "/oho"; // 기본 리다이렉트
    }
    // 세션 무효화
    HttpSession session = request.getSession(false); // false -> 새 세션을 만들지 않고 이미 있는 세션만 가져 옴
    if (session != null) session.invalidate();
    
    response.sendRedirect(redirectPath);
  }
}
```

<!-- &nbsp;&nbsp;사용자 유형과 접근 경로에 따라 로그아웃 후 이동 경로가 달라야 했기 때문에,
`LogoutSuccessHandler`를 커스터마이징하여 요청 URI를 기준으로 리다이렉트 경로를 동적으로 분기 처리하였습니다.
&nbsp;&nbsp;요청 URI가 `/oho`, `/shop`, `/admin`, `/emp` 등으로 시작하는지를 판별하여, 로그아웃 후 각각에 맞는 페이지로 자동 이동되도록 구성하였습니다. 예를 들어 `/admin` 경로에서 로그아웃 요청이 들어온 경우, 자동으로 `/admin/login`으로 이동됩니다.
&nbsp;&nbsp;또한, 로그아웃 시 사용자의 세션을 명시적으로 `invalidate()` 처리하여 **보안을 강화하고 불필요한 세션 자원을 정리**할 수 있도록 하였습니다.
&nbsp;&nbsp;이러한 구조는 역할별로 독립된 로그아웃 후 흐름을 유지하면서도, 모든 처리를 하나의 클래스에서 통합 관리함으로써 **코드 중복 없이 유지보수성과 확장성을 높인** 사례입니다. -->

- 요청 URI 기준으로 페이지 분기 처리를 합니다.
  - `/admin` → `/admin/login`
  - `/emp` → `/emp/login`
  - `/shop` or `나머지 URI` → `/oho`
- 세션을 명시적으로 `invalidate()` 처리하여 **보안을 강화하고 불필요한 세션 자원을 정리**할 수 있도록 하였습니다.

**➡️ 역할별로 독립된 로그아웃 후 흐름을 유지하면서도, 모든 처리를 하나의 클래스에서 통합 관리함으로써 코드 중복 없이 유지보수성과 확장성을 높인 사례입니다.**  
<br>

<a name="exception"></a>

**4) 예외 처리**

**4-1. 인증되지 않은 사용자 접근 시**

```java
@Slf4j
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint{

  @Override
  public void commence(HttpServletRequest request, HttpServletResponse response,
            AuthenticationException authException) throws IOException, ServletException {
        
    String requestURI = request.getRequestURI();
    String redirectUrl = "/loginRequired?from=" + URLEncoder.encode(requestURI, "UTF-8");
    
    response.sendRedirect(redirectUrl);
  }

}
```

<!-- &nbsp;&nbsp;인증되지 않은 사용자가 보호된 자원(URL)에 접근할 경우, *Spring Security*에서는 기본적으로 로그인 페이지로 리다이렉트합니다. 하지만 사용자 유형(관리자, 직원, 일반 회원)에 따라 접근 경로가 다르기 때문에, `AuthenticationEntryPoint`를 커스터마이징하여 **요청된 URI를 파악한 뒤, 적절한 로그인 페이지로 연결할 수 있도록 동적 분기 처리**를 구현하였습니다.
&nbsp;&nbsp;요청 URI는 `URLEncoder`를 통해 쿼리스트링 형식으로 인코딩되어 `/loginRequired?from=요청경로`로 전달되며, `/loginRequired` 내부에서는 전달된 `from` 값을 기준으로 사용자의 의도에 맞는 로그인 페이지로 안내하게 됩니다.
&nbsp;&nbsp;이러한 구조는 인증 실패 시 사용자에게 일관된 안내 흐름을 제공하며, 추후 로그인 페이지 구조나 권한 체계가 변경되더라도 **핸들러 하나로 쉽게 대응할 수 있는 유연한 구조를 제공**합니다. -->

- 요청된 URI를 파악한 뒤, 적절한 로그인 페이지로 연결할 수 있도록 동적 분기 처리를 구현하였습니다.
  - 요청 URI → `/loginRequired?from=요청경로`
  - `/loginRequired` 내부에서는 전달된 `from` 값을 기준으로 사용자의 의도에 맞는 로그인 페이지로 안내

**➡️ 인증 실패 시 사용자에게 일관된 안내 흐름을 제공하며, 추후 로그인 페이지 구조나 권한 체계가 변경되더라도 핸들러 하나로 쉽게 대응할 수 있는 유연한 구조를 제공합니다.**  
<br>

<a name="bcrypt"></a>

**5) BCryptPasswordEncoder 암호화**  
&nbsp;&nbsp;로그인 기능 구현 시 사용자 정보를 안전하게 보호하기 위해 *Spring Security*의 암호화 방식 중 하나인 `BCryptPasswordEncoder`를 적용하였습니다.  

```java
@Autowired
BCryptPasswordEncoder bCryptPasswordEncoder;

// 회원가입
@Override
@Transactional
public int signUp(MemberVO memberVO) {
    String memPswd = memberVO.getMemPswd();
    memPswd = this.bCryptPasswordEncoder.encode(memPswd);
    String memBirth = memberVO.getMemBirth();
    memBirth = memBirth.replaceAll("[^0-9]", "");
    
    memberVO.setMemPswd(memPswd); // 암호화된 패스워드를 set
    memberVO.setMemBirth(memBirth); // 하이픈 제거한 생년월일
    
    int result = this.memberMapper.signUp(memberVO);
    
    if(result > 0) this.memberMapper.insertAuth(memberVO);
    
    return result;
}
```
&nbsp;&nbsp;**BCrypt는 단방향 해시 함수 기반**으로, **내부적으로 salt 값을 자동으로 추가**하여 동일한 비밀번호라도 매번 다른 결과가 생성되며, **복호화가 불가능한 형태로 암호화**되어 데이터베이스에 저장됩니다. 이를 통해 **외부 유출 상황에서도 원본 비밀번호의 노출을 효과적으로 방지**할 수 있었습니다.  
  
&nbsp;&nbsp;또한 BCrypt는 **비용 인자(cost factor)**를 조절하여 연산 난이도를 설정할 수 있고, **다양한 해킹 기법에 강한 보안성**을 제공하기 때문에 *Spring Security*에서도 기본 방식으로 채택하고 있다는 점을 학습할 수 있었습니다.  
  
&nbsp;&nbsp;이번 구현을 통해 **단순히 암호화를 적용하는 것을 넘어, 적절한 알고리즘을 선택하고 그 특성을 정확히 이해하는 것**이 보안 구현에 있어 매우 중요하다는 점을 체감하였습니다.  
<br>

<a name="smtp"></a>

**6) SMTP 인증번호 이메일 발송**  
&nbsp;&nbsp;회원가입 시, **이메일 인증 기능을 구현**하여 사용자 본인 확인 절차를 강화하였습니다.  

![기능구현](/assets/img/pro/ems/my-part/인증번호전송.gif "인증번호전송")
<center><small>인증번호발송 및 타이머.gif</small></center>   
<br>

```javascript
// 1. 인증코드 발송
axios.post("/sendCode", { email }).then(resp => {

    Swal.close();

    // 1-1. 발송 성공 alert
    sendSuccess();
    // 1-2. 인증유효시간 타이머
    startCountdown(180);
    // 1-3. 이메일 입력창 readonly
    $("#email").attr("readonly", true);
    // 1-4. 인증번호 발송 버튼 지우기
    document.getElementById("valiBtn").remove();
    // 1-5. 인증코드 입력창 활성화
    document.getElementById("codeSectionDiv").style.display = "block";
    // 1-6. 인증확인 버튼 활성화
    document.getElementById("verifyCodeBtn").style.display = "block";

}).catch(()=> {
    sendFail();
});
```
&nbsp;&nbsp;사용자가 **이메일 인증을 요청하면** `axios`**를 통해 서버에 비동기 요청을 보내 인증번호가 전송**되며, 이후 타이머 동작, 이메일 입력창 `readonly` 설정, 인증번호 입력란 및 인증 버튼 표시 등 인증 절차가 순차적으로 진행되도록 구성하였습니다. 이를 통해 인증 흐름에 맞춘 UI와 사용자 경험을 함께 고려한 기능을 구현하였습니다.  
<br>

![기능구현](/assets/img/pro/ems/my-part/인증만료.gif "인증만료")
<center><small>인증시간만료.gif</small></center>  
<br>

&nbsp;&nbsp;인증번호의 **유효 시간을 시각적으로 안내**하기 위해 JavaScript의 `setInterval`을 활용한 **타이머 카운트다운 기능을 구현**하였습니다. 인증번호가 발송되면 타이머가 시작되어 **남은 시간을 실시간으로 표시**하며, **시간이 만료되면 만료 메시지를 출력**하여 사용자에게 **직관적으로 인증 상태를 안내**할 수 있도록 구성하였습니다.  
 
<br>

```javascript
// 인증코드 유효시간 카운트 다운
let timerInterval;

function startCountdown(durationInSeconds) {
    const display = document.getElementById("timer");
    let time = durationInSeconds;

    clearInterval(timerInterval); // 혹시 이전 타이머가 있으면 제거

    timerInterval = setInterval(() => {
        const minutes = Math.floor(time / 60);
        const seconds = time % 60;
        display.textContent = `${i18n3.timer}: ${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;

        if (--time < 0) {
            clearInterval(timerInterval);
            display.textContent = "⏰"+i18n3.timeOut+"!";
        }
    }, 1000);
}
```
&nbsp;&nbsp;인증번호는 **발급 시점 기준 3분간 유효**하며, 시간이 초과되면 서버에서 자동 만료 처리하고 **"timeout" 응답을 반환**합니다. 클라이언트는 이 응답을 기반으로 즉각적인 Alert 메시지를 출력하여 사용자에게 만료 사실을 명확히 안내하며, **입력 실수로 인한 혼란을 줄이고 정확한 재인증을 유도**할 수 있도록 구성하였습니다. 이를 통해 **클라이언트-서버 간 상태 동기화, 보안성, 사용자 경험(UX)**을 모두 고려한 인증 흐름을 구현하였습니다.<br>
<br>

```java
// 인증코드 발송
@ResponseBody
@PostMapping("/sendCode")
public ResponseEntity<?> sendCode(@RequestBody Map<String, Object> map, HttpSession session) {
    String email = (String) map.get("email");
    String code = createCode();
    
    // 인증 정보 객체 생성
    Map<String, Object> authInfo = new HashMap<>();
    authInfo.put("code", code);
    authInfo.put("time", System.currentTimeMillis());
    
    // 세션에 저장
    session.setAttribute("auth_" + email, authInfo);
    
    sendEmail(email, code);
    
    return ResponseEntity.ok().build();
}

// 인증코드 6자리 생성
private String createCode() {
    return String.valueOf((int)(Math.random() * 900000 ) + 100000 );
}

// 설정한 메일로 코드 전송 설정
private void sendEmail(String email, String code) {
    SimpleMailMessage message = new SimpleMailMessage();
    message.setTo(email);
    message.setSubject("[oHoT] 이메일 인증 코드");
    message.setText("인증코드: " +  code);
    mailSender.send(message);
}
```

&nbsp;&nbsp;인증 요청 시 서버에서 **6자리 인증 코드를 생성**하고, `SimpleMailMessage`를 활용해 사용자의 이메일로 전송하는 기능을 구현하였습니다. 이메일 전송은 **Gmail의 SMTP 서버를 기반**으로 하며, 관련 설정은 `application.properties`에 구성하였습니다.  
  
&nbsp;&nbsp;생성된 인증 코드는 **세션에 저장**되어 **유효 시간 내에만 입력 가능**하도록 제한함으로써 **보안성을 강화**하였으며, 세션 기반 인증 처리로 인증 흐름의 신뢰성을 높였습니다.  
<br>

```xml
# SMTP 설정
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
```
&nbsp;&nbsp;Gmail SMTP 연동 시, **2차 인증이 활성화된 계정**의 경우 **앱 비밀번호를 활용하여 인증을 수행**하였으며, 이를 통해 `JavaMailSender`가 **외부 메일 서버를 통해 안정적으로 메일을 송신**할 수 있도록 설정하였습니다. 이 과정을 통해 **SMTP 프로토콜의 작동 원리, 외부 메일 서버 연동 방식, 이메일 인증 로직과 세션 기반 보안 처리 전략**, 그리고 **Spring Boot 환경에서의 메일 발송 설정 및** `JavaMailSender` **활용법**을 실무 수준에서 학습할 수 있었습니다.<br>
<br>

```java
// 인증번호 일치 여부 확인
@ResponseBody
@PostMapping("/verifyCode")
public ResponseEntity<?> verifyCode(@RequestBody Map<String, Object> map, HttpSession session) {
    String email = (String)map.get("email");
    String inputCode = (String)map.get("code");
    
    @SuppressWarnings("unchecked")
    Map<String, Object> authInfo = (Map<String, Object>) session.getAttribute("auth_"+email);
    
    // 해당 이메일에 대한 인증정보 객체가 없을 경우
    if(authInfo == null) return ResponseEntity.ok("fail");
    
    String correctCode = (String)authInfo.get("code");
    long sentTime = (long)authInfo.get("time");
    long now = System.currentTimeMillis();
    
    // 유효시간 (3분 = 180,000 ms) 초과 했을 경우
    if(now-sentTime > 180000) {
        // session에서 해당 이메일 삭제
        session.removeAttribute("auth_"+email);
        return ResponseEntity.ok("timeOut");
    }
    
    // 입력코드와 세션에 저장된 코드(발급된코드)가 일치할 경우
    if(inputCode.equals(correctCode)) {
        // session에서 해당 이메일 삭제
        session.removeAttribute("auth_"+email);
        return ResponseEntity.ok("success");
    }
    
    return ResponseEntity.ok("fail");
}
```

&nbsp;&nbsp;인증번호 검증 시, 사용자가 입력한 코드와 **세션에 저장된 코드를 비교**하여 본인 확인을 수행하도록 구현하였으며, **인증번호 발급 시점을 기준으로 3분이 경과하면 자동 만료**되도록 설정하여 일정 시간 내 인증을 유도하고 **무단 인증 시도를 방지**하였습니다. 이러한 방식은 시간 기반 인증 제한을 통해 **보안성과 시스템 안정성**을 높이는 데 기여하였으며, 사용자 인증 흐름에서 발생할 수 있는 **위조 시도를 효과적으로 제어**할 수 있도록 설계하였습니다.<br><br>

<a name="oauth2"></a>

**7) Spring Security 의 OAuth2 Client 설정(KAKAO API)**
<br>

```xml
# Spring Security OAuth2 Client 설정
spring.security.oauth2.client.registration.kakao.client-authentication-method=client_secret_post
spring.security.oauth2.client.registration.kakao.authorization-grant-type=authorization_code
spring.security.oauth2.client.registration.kakao.redirect-uri=http://localhost:28080/login/oauth2/code/kakao
spring.security.oauth2.client.registration.kakao.scope=profile_nickname,account_email
spring.security.oauth2.client.registration.kakao.client-name=Kakao
# 공급자 정보 (kakao)
spring.security.oauth2.client.provider.kakao.authorization-uri=https://kauth.kakao.com/oauth/authorize
spring.security.oauth2.client.provider.kakao.token-uri=https://kauth.kakao.com/oauth/token
spring.security.oauth2.client.provider.kakao.user-info-uri=https://kapi.kakao.com/v2/user/me
spring.security.oauth2.client.provider.kakao.user-name-attribute=id
```

&nbsp;&nbsp;**Spring Security**의 **OAuth2 Client** 기능을 활용하여 **카카오 로그인을 구현**하였습니다. 사용자는 아이디와 비밀번호를 직접 입력하지 않고도 카카오 계정을 통해 안전하게 로그인할 수 있으며, 인증 과정은 카카오 서버에서 처리되기 때문에 **민감한 정보가 노출되지 않아 보안성이 향상**됩니다.  
  
&nbsp;&nbsp;또한, 로그인 시 어떤 사용자 정보를 받아올지 결정하는 `scope`와 사용자 식별에 사용할 속성을 지정하는 `user-name-attribute` 설정을 직접 적용하며 **OAuth2**의 구조와 설정 방식에 대한 이해를 실습을 통해 깊이 있게 다질 수 있었습니다. 해당 구조는 **Google, Naver** 등 다른 **OAuth2** 로그인 방식도 **손쉽게 확장할 수 있도록 설계**되어, 유지보수성과 확장성 측면에서도 유리한 방식입니다.<br><br>

---

### 메인페이지

<a name="auth-ui"></a>

**1) 인증 / 권한에 따른 UI 구성**  
&nbsp;&nbsp;*JSTL Security* 태그 (`sec:authorize`)를 활용하여 인증 여부에 따라 회원과 비회원에게 서로 다른 UI 요소가 출력되도록 구성하였습니다.
<br>

- 비회원 화면 (메인 header)

![기능구현](/assets/img/pro/ems/my-part/비회원헤더.png "비회원헤더")<br>
<center><small>비회원 헤더 화면</small></center>  
<br>

```javascript
<sec:authorize access="!isAuthenticated()">
    <li>
        <a class="btn-getstarted" href="javascript:void(0)" onclick="redirectToLogin()">
            <spring:message code="signin" />
        </a>
    </li>
</sec:authorize>
```  
<br>

- 회원 화면 (메인 header)

![기능구현](/assets/img/pro/ems/my-part/회원헤더.png "회원헤더")<br>
<center><small>비회원 헤더 화면</small></center>  
<br>

```javascript
<sec:authorize access="isAuthenticated()">
        <!-- 검색 버튼 -->
        <li id="searchToggle"> ... </li>
        
        <!-- 알림 버튼 -->
        <li class="alarm-wrapper" style="position: relative;"> ... </li>
        
        <!-- MY 버튼 -->
        <li class="dropdown"> ... </li>
</sec:authorize>
```
<br>

<a name="search-function"></a>

**2) 검색 기능**

```javascript
let debounceTimer;
 
// 검색 입력 시 드롭다운 결과 표시
searchInput.addEventListener("input", function () {
    const keyword = this.value.trim();

    // 이전 타이머 제거
    clearTimeout(debounceTimer);

    // 새 타이머 등록
    debounceTimer = setTimeout(() => {
    if (keyword.length < 1) {
        searchResults.style.display = "none";
        searchResults.innerHTML = "";
        return;
    }
        
axios.get("/oho/searchArtGroupList?keyword="+keyword).then(resp => {
        const data = resp.data;
        
        if(data.length === 0) { 
            searchResults.innerHTML = `<div class='dropdown-item text-muted'>${i18n.notFound}</div>`; 
        } else {
            searchResults.innerHTML = data.map(group => 
            `
                <a href="/oho/groupProfile?artGroupNo=${group.artGroupNo}" class="dropdown-item">
                    <img src="/upload${group.fileGroupVO.fileDetailVOList[0].fileSaveLocate}">
                    <div>
                        <div class="fw-bold">${group.artGroupNm}</div>
                    </div>;
                </a>;
            `
            ).join("");;
        }
        searchResults.style.display = "block";
    }).catch(err => {
        console.error("검색 중 오류 발생:", err);
        searchResults.innerHTML = `<div class='dropdown-item text-danger'>${i18n.searchFail}</div>`;
        searchResults.style.display = "block";
    });
        
  }, 300); // 입력 멈추고 300ms 뒤에 실행	
});
```
&nbsp;&nbsp;검색 기능 구현 시, 사용자 입력 이벤트에 **300ms 디바운싱 로직을 적용**하여, **일정 시간 동안 입력이 멈췄을 때만 검색 API가 호출**되도록 구성하였습니다.  
  
&nbsp;&nbsp;이를 통해 불필요한 요청을 줄여 **서버 부하를 완화**하고, 실시간 검색 중 발생할 수 있는 **네트워크 트래픽 낭비도 최소화**할 수 있었습니다. 또한, 검색 결과는 **동적으로 렌더링되는 HTML 구조로 구성**하여, 아티스트 이미지와 이름을 함께 제공함으로써 시각적 정보 전달력을 높였습니다.<br><br><br>

![기능구현](/assets/img/pro/ems/my-part/검색화면.gif "검색화면")
<center><small>검색화면</small></center>  
<br>

```java
<if test="keyword != null">
    AND (
        LOWER(ag.art_group_nm) LIKE '%' || LOWER(#{keyword}) || '%'
        OR LOWER(ag.art_group_nm_ko) LIKE '%' || LOWER(#{keyword}) || '%'
        )
</if>
```


&nbsp;&nbsp;검색어(keyword)에 대해 영어명(art_group_nm)과 국문명(art_group_nm_ko) 컬럼을 모두 조회할 수 있도록 **OR 조건을 적용**하였으며, LOWER() 함수를 활용해 대소문자 구분 없이 **다국어 검색이 가능하도록 구현**하였습니다.  
<br>

<a name="message"></a>

**3) 스프링 메시지 기반 다국어처리**<br>

&nbsp;&nbsp;글로벌 사용자 대응을 위해 **Spring MessageSource**를 활용하여 다국어 지원 기능을 구현하였습니다.

**- 백엔드에서의 설정**

![기능구현](/assets/img/pro/ems/my-part/메시지파일.png "메시지파일")<br>

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Bean
    public LocaleResolver localeResolver() {
        SessionLocaleResolver resolver = new SessionLocaleResolver();
        resolver.setDefaultLocale(Locale.KOREA); // 기본 로케일
        return resolver;
    }

    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor() {
        LocaleChangeInterceptor interceptor = new LocaleChangeInterceptor();
        interceptor.setParamName("lang"); // ex: ?lang=en
        return interceptor;
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(localeChangeInterceptor());
    }
}
```  
<br>

**- 프론트엔드에서의 설정**

![기능구현](/assets/img/pro/ems/my-part/로케일설정.png "로케일설정")<br>

```html
<select class="form-select me-3" style="width: 70px;" name="lang" onchange="changeLang(this)">
    <option value="ko" <c:if test="${sessionScope.lang == 'ko' || empty sessionScope.lang}">selected</c:if>>KO</option>
    <option value="en" <c:if test="${sessionScope.lang == 'en'}">selected</c:if>>EN</option>
</select>
```  

```javascript
function changeLang(select) {
    const url = new URL(window.location.href);
    url.searchParams.set("lang", select.value);
    window.location.href = url.toString();
    }
```


&nbsp;&nbsp;Spring의 `LocaleResolver`와 `LocaleChangeInterceptor`를 활용해 **URL 파라미터(?lang)로 언어 변경을 처리**하고, 사용자 선택에 따라 메시지가 동적으로 전환되도록 구성하였으며, 각 언어별 메시지는` messages_{locale}.properties` 파일로 분리 관리하고, 프론트엔드에서는 **언어 선택 시 해당 파라미터를 변경하는 방식**으로 구현하였습니다.<br><br>

<a name="translation"></a>

**4) 번역기능 (Cloud Translation API)**  

&nbsp;&nbsp;사용자 간 원활한 소통을 위해 `Google Cloud Translation API`를 활용하여, 댓글 및 게시글을 **자동으로 영어로 번역하는 기능을 구현**하였습니다.<br>
![기능구현](/assets/img/pro/ems/my-part/번역화면.png "번역화면")
<center><small>번역화면</small></center>  
<br>

&nbsp;&nbsp;현재는 모든 콘텐츠가 영어로 자동 번역되도록 구성되어 있으나, **추후에는 사용자의 로케일 설정을 감지**하여, **로케일 언어와 다른 경우에만 해당 언어로 번역되도록 개선할 계획**입니다. 이를 통해 다양한 언어 사용자가 보다 자연스럽게 콘텐츠를 이해하고 소통할 수 있도록 할 예정입니다.<br>
<br>

```javascript
<p id="repCreateDt">${communityReplyVO.repCreateDate}</p>
<p class="mb-1 card-reply" data-original="\${communityReplyVO.replyContent}">
    ${communityReplyVO.replyContent}
</p>
<button class="reply-translate-btn" onclick="commuReplyTrans()"
                             data-lang="en" data-status="original">
    번역하기
</button>
<button class="btn btn-outline-danger" id="replyLikeBtn\${communityReplyVO.replyNo}"
        onclick="fn_reply_likeYn(\${boardNo}, \${communityReplyVO.replyNo})">
    <i id="heartIcon\${communityReplyVO.replyNo}" class="bi bi-heart"></i>
    <span id="replyLikeCnt\${communityReplyVO.replyNo}">
        ${communityReplyVO.replyLikeCnt}
    </span>
</button>
```  

```javascript
// 댓글 번역
async function commuReplyTrans() {
    const transBtn = event.target;
    const target = transBtn.dataset.lang;
    const replyTag = transBtn.previousElementSibling;
    const status = transBtn.dataset.status;
    
    if (status === 'original') {
        const replyData = {
                text : replyTag.innerText,
                target : target
        }
        try {
            const replyResult = await axios.post("/api/translate", replyData);
            
            // 번역 내용 표시
            replyTag.innerText = replyResult.data;
                
            // 버튼명/상태 변경
            transBtn.innerText = '원본보기';
            transBtn.dataset.status = 'translated';
        } catch(e) {
            console.log("번역 실패", e);
        }
    } else { // 원본보기
        replyTag.innerText = replyTag.dataset.original;

        transBtn.innerText = '번역하기';
        transBtn.dataset.status = 'original';
    }
}
```

&nbsp;&nbsp;번역된 댓글을 다시 원문으로 되돌릴 때 발생할 수 있는 오역을 방지하기 위해, **댓글의 원문을** `data-original` **속성에 저장**하고, **‘원본 보기’ 버튼 클릭 시 해당 속성의 값을 활용해 텍스트를 정확히 복원**할 수 있도록 구현하였습니다.  
  
---

### 마이페이지

<a name="my-page"></a>

**1) 회원 정보 조회 및 수정**  

&nbsp;&nbsp;마이페이지에서는 **개인정보를 수정**하거나, 작성한 문의글을 **‘문의함’을 통해 조회**할 수 있으며, **회원 탈퇴**도 가능합니다.

![기능구현](/assets/img/pro/ems/my-part/마이페이지.png "마이페이지")
<center><small>마이페이지화면</small></center>  
<br>

&nbsp;&nbsp;예를 들어, **비밀번호를 수정**할 경우 아래와 같은 화면이 표시됩니다.

![기능구현](/assets/img/pro/ems/my-part/비밀번호변경.gif "비밀번호변경")
<center><small>비밀번호 변경 모달 화면</small></center>  
<br>

&nbsp;&nbsp;비밀번호는 **정해진 validation 규칙을 모두 만족해야만 저장 가능**하며, **정합성 검사는 프론트엔드 단에서 사전 검증**하도록 처리하였습니다.  또한 **비밀번호 입력란 옆의 토글 버튼을 통해 비밀번호 보이기/숨기기 전환 기능도 함께 제공**하여 사용자 편의성을 높였습니다.  
  
&nbsp;&nbsp;해당 기능의 코드는 다음과 같습니다.  

```javascript
newPwInput.addEventListener("input", function () {
  const pw = this.value;
  const isLengthOk = pw.length >= 8 && pw.length <= 32;
  const hasLetter = /[a-zA-Z]/.test(pw);
  const hasNumber = /[0-9]/.test(pw);
  const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(pw);

  ruleLength.classList.toggle("valid", isLengthOk);
  ruleLetter.classList.toggle("valid", hasLetter);
  ruleNumber.classList.toggle("valid", hasNumber);
  ruleSpecial.classList.toggle("valid", hasSpecial);

  isPwValid = isLengthOk && hasLetter && hasNumber && hasSpecial;
  checkPwMatch();
});
```
&nbsp;&nbsp;사용자가 새 비밀번호를 입력할 때마다 **실시간으로 정합성 검사**를 하며, 각각의 규칙을 만족하면 해당 항목의 색상이 초록색으로 변경됩니다. 모든 조건을 만족해야만 다음 단계로 진행할 수 있도록 `isPwValid` **플래그로 상태를 저장**합니다.  

<br>

```javascript
function checkPwMatch() {
  if (pwConfirm.value === "") return;

  if (pwConfirm.value === newPw.value) {
    pwMsg.textContent = isPwValid ? "비밀번호가 일치합니다." : "형식을 다시 확인해주세요.";
    pwMsg.style.color = isPwValid ? "green" : "red";
    savePswdBtn.style.display = isPwValid ? "inline-block" : "none";
  } else {
    pwMsg.textContent = "비밀번호가 일치하지 않습니다.";
    pwMsg.style.color = "red";
    savePswdBtn.style.display = "none";
  }
}
```

&nbsp;&nbsp;위 함수는 **비밀번호 재입력값이 실제 비밀번호와 일치하는지를 실시간으로 확인**하고, 일치 여부에 따라 메시지를 표시하거나 저장 버튼의 활성화를 제어합니다. 유효성까지 통과해야만 저장 버튼이 노출되며, 잘못된 형식이나 불일치 시에는 붉은색 메시지로 경고를 제공합니다.  
<br>

---

### 아티스트 소개 페이지

<a name="spotify"></a>

**1) Spotify API 를 통한 1분 미리 듣기 구현**  

![기능구현](/assets/img/pro/ems/my-part/그룹프로필.gif "그룹프로필")
<center><small>아티스트 소개 화면</small></center>  
<br>

&nbsp;&nbsp;아티스트 소개 페이지는 **그룹 및 멤버에 대한 기본 정보를 제공**하며, 커뮤니티에 등록된 미디어 영상과 연동된 굿즈샵 일부를 함께 노출하여 **팬과의 연결성을 높인 공간**입니다. 또한, 그룹의 앨범은 **Spotify API를 통해 1분 미리듣기 기능을 제공**하여 사용자가 아티스트의 음악을 간편하게 경험할 수 있도록 구성하였습니다.
<br>

&nbsp;&nbsp;Spotify API 구현 코드는 다음과 같습니다.  
<br>

**1. Spotify 토큰 발급 받기**

```java
@Slf4j
@Component
public class SpotifyApiCreateToken {
    @Value("${spotify.client.id}")
    private String clientId;
    @Value("${spotify.client.secret}")
    private String clientSecret;
    
     public String accesstoken() throws ParseException, SpotifyWebApiException {
         
        SpotifyApi spotifyApi = new SpotifyApi.Builder()
                .setClientId(clientId)
                .setClientSecret(clientSecret)
                .build();
         
        ClientCredentialsRequest clientCredentialsRequest = spotifyApi.clientCredentials().build();
        try {
            final ClientCredentials clientCredentials = clientCredentialsRequest.execute();
            spotifyApi.setAccessToken(clientCredentials.getAccessToken());
            
            return spotifyApi.getAccessToken();

        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
            return "error";
        }
    }

}
```

&nbsp;&nbsp;Spotify의 **Client Credentials Flow 방식을 사용해 Access Token을 발급**받는 코드입니다. `clientId`와 `clientSecret`은 `application.properties`에 설정된 값을 주입받으며, 토큰 발급 성공 시 반환된 토큰을 `SpotifyApi` 인스턴스에 등록하고 반환합니다. 예외 발생 시 오류 로그를 출력하고 `"error"` 문자열을 반환합니다.  
<br>

**2. Spotify Player 생성**

```java
@GetMapping("/groupProfile")
public String groupProfile(ArtistGroupVO artistGroupVO
                            , Model model
        ) throws Exception {
    
    artistGroupVO = this.groupProfileService.getArtistGroup(artistGroupVO.getArtGroupNo());
    
    String artGroupNm = artistGroupVO.getArtGroupNmKo(); // 국문명
    String accessToken = spotifyApiCreateToken.accesstoken();
    String result = spotiryApiServiceImpl.search(accessToken, artGroupNm);

    String albumId = null;
    try {
        JSONObject json = new JSONObject(result);
        JSONArray items = json.getJSONObject("tracks").getJSONArray("items");
        if (items.length() > 0) {
            albumId = items.getJSONObject(1).getJSONObject("album").getString("id");
        }
    } catch (Exception e) {
        log.error("Spotify JSON 파싱 에러", e);
    }
    
    model.addAttribute("albumId", albumId);
    
    return "community/groupProfile";
}
```

&nbsp;&nbsp;**발급받은 Access Token을 이용해 아티스트 이름으로 Spotify 검색 API를 호출**하고, 응답된 JSON에서 **앨범 ID를 추출하는 로직**입니다. 추출된 앨범 ID는 `groupProfile.jsp`로 전달되어 Spotify Player로 사용되며, **1분 미리듣기**에 활용됩니다. 검색 키워드는 기본적으로 **국문 그룹명**을 사용하며, 예외 처리 구간에서 JSON 파싱 실패 시 에러 로그를 남깁니다.  
<br>

---

### 문의 글 화면

<a name="tree"></a>

**1) 트리 구조 구현**  

![기능구현](/assets/img/pro/ems/my-part/메인문의글화면.gif "메인문의글화면")
<center><small>메인 문의글 화면</small></center>  
<br>

```xml
<select id="getInquiryPostList" parameterType="hashMap" resultMap="boardPostMap">
    SELECT *
    FROM (
        SELECT TMP.*, ROWNUM AS RNUM
        FROM (
            SELECT
                LEVEL,
                bp.bbs_post_no,
                -- 트리 구조 표현
                CASE
                    WHEN LEVEL = 1 THEN bp.bbs_title
                    ELSE RPAD('│   ', (LEVEL - 2) * 4, '│   ') || '└ ' || bp.bbs_title
                END AS bbs_title,
                bp.parent_post_no,
                ip.inq_writer,
                bp.bbs_reg_dt
            FROM board_post bp
            LEFT JOIN inquiry_post ip ON bp.bbs_post_no = ip.bbs_post_no
            WHERE bp.bbs_type_cd_no = 4
            START WITH bp.parent_post_no IS NULL
            CONNECT BY PRIOR bp.bbs_post_no = bp.parent_post_no
            ORDER SIBLINGS BY bp.bbs_post_no DESC
        ) TMP
        WHERE ROWNUM <= #{end}
    )
    WHERE RNUM >= #{start}
</select>
```

&nbsp;&nbsp;본 쿼리는 게시판 트리 구조 구현을 위한 `CONNECT BY`, `LEVEL`, `RPAD` 활용 로직을 중심으로 요약하였습니다.
나머지 컬럼, JOIN, 동적 `<if>` 조건문 등은 가독성을 위해 생략 처리하였습니다.

&nbsp;&nbsp;Oracle의 `CONNECT BY`와 `LEVEL`을 활용하여 **부모-자식 관계를 트리 구조**로 조회하고,
`RPAD`와 `CASE`를 이용해 계층 깊이에 따라 게시글 제목에 들여쓰기 및 기호(`└`, `│`)를 삽입해 시각적인 트리 형태로 표현했습니다.  
<br>

<a name="ckeditor"></a>

**2) CKEditor 활용 (이미지 업로드 구현)**  

![기능구현](/assets/img/pro/ems/my-part/ckeditor.gif "ckeditor")
<center><small>CKEditor 이미지 업로드</small></center>  

```java
public List<MultipartFile> ckEditorUpload(BoardPostVO boardPostVO) throws IOException {
    
    String html = boardPostVO.getBbsHtmlCn();
    List<String> imageUrls = extractImageUrls(html);
    
    List<MultipartFile> multipartFileList = new ArrayList<>();
    
    for(String imageUrl : imageUrls) {
        if(imageUrl.contains("/images/temp/")) { // 웹 경로
            
            String fileName = imageUrl.substring(imageUrl.lastIndexOf("/") + 1);
            File tempFile = new File("C:/workspace/tempUpload/" + fileName);
            
            if (tempFile.exists()) {
                byte[] content = FileUtils.readFileToByteArray(tempFile);

                MultipartFile multipartFile = new MockMultipartFile(
                        "upload",
                        fileName,
                        Files.probeContentType(tempFile.toPath()),
                        content
                );

                multipartFileList.add(multipartFile);
            } else {
                log.warn("파일이 없음 : " + tempFile.getAbsolutePath());
            }
        }
    }
    return multipartFileList;
}
```
&nbsp;&nbsp;`CKEditor`를 사용하여 게시글을 작성할 때, 에디터에 업로드된 이미지는 임시 경로 (/images/temp/)에 저장되어 게시글 저장 이후 파일 유실 또는 외부 이미지 링크 문제로 콘텐츠 연속성이 저하되는 문제가 발생하였습니다. 이를 해결하기 위해, **게시글 저장 시 에디터 본문 내 이미지를 서버의 관리 대상 디렉토리로 안전하게 이동**하는 기능을 구현하였습니다.  
<br>

<a name="xss"></a>

**3) XSS 공격 방어**  

![기능구현](/assets/img/pro/ems/my-part/XSS공격.gif "XSS공격")
<center><small>XSS 공격 방어</small></center>  
<br>

```javascript
const saveBtn = document.getElementById("saveBtn");
   if (saveBtn) {
       saveBtn.addEventListener("click", () => {
        let htmlContent = window.editor.getData();
        let bbsTitle = document.getElementById("bbsTitle").value; 
        
        htmlContent = escapeHtml(htmlContent);
        bbsTitle = escapeHtml(bbsTitle);
        
        // HTML을 임시 div에 넣고 textContent만 추출
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = htmlContent;
        const plainText = tempDiv.textContent // textContent 부분만 추출
        tempDiv.innerText = plainText;
        
        // hidden input에 plain text 저장
        document.getElementById("plainText").value = plainText;
        
        if (plainText.trim() === "") {
            alert("내용을 입력해주세요.");
            document.querySelector('.ck-editor__editable').style.border = '2px solid red';
            return; // 제출 막기
        } else {
            document.querySelector('.ck-editor__editable').style.border = '';
        }
        
        document.getElementById("bbsTitle").value = bbsTitle;
        const form = document.querySelector("#frmEditSubmit");
        if (form.checkValidity()) {
                form.submit(); // 통과하면 제출
            }else {
                form.reportValidity(); // 실패 시 오류 메시지 표시
            }
    })
}
```  

```javascript
function escapeHtml(str) {
    return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "<")
    .replace(/>/g, ">")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}
```

&nbsp;&nbsp;사용자가 입력한 콘텐츠 내 스크립트 실행을 차단해 **XSS(Cross-Site Scripting) 공격을 방지**하기 위해, **특수 문자(`<`, `>`, `"`, `'`, `&`)를 HTML 엔티티로 변환하는 `escapeHtml` 함수를 직접 구현**하였으며, 이 기능은 게시글 작성 시 클라이언트 측에서 실행되어 콘텐츠가 **서버로 전송되기 전에 잠재적인 악성 코드가 HTML 구조로 해석되지 않도록 처리**함으로써 보안성과 데이터 무결성을 향상시켰습니다.  

<br>

<a name="pswd-config"></a>

**3) 비밀번호 설정 기능**  

&nbsp;&nbsp;문의글은 작성 시 **비밀번호 설정이 가능**하며, 비밀글로 작성된 경우에는 접근 시 비밀번호 입력 모달이 표시되어 **개인정보 보호와 접근 제어**가 가능하도록 구현하였습니다.

![기능구현](/assets/img/pro/ems/my-part/문의글비밀번호.png "문의글비밀번호")
<center><small>문의글 비밀번호 모달화면</small></center>  
<br>

&nbsp;&nbsp;비밀번호 검사 로직은 다음과 같습니다.

```javascript
//게시글을 눌렀을 때
function fn_clickPost(postNo, pswdYn) {
    if(pswdYn == "N") { // 공개글일 경우
        inquiryPostDetail(postNo);
    }else {  // 비밀글일 경우
        // 비밀번호 입력 모달창 열기
        const pswdModal =	document.getElementById("pswdModal");
        pswdModal.style.display = "flex";
        
        // 입력버튼 클릭했을 경우
        const nextBtn = document.getElementById("nextBtn");

        nextBtn.addEventListener("click", () => {
            const inputPswd = document.getElementById("inputPswd").value;
            
            axios.post("/oho/inquiryPost/pswdCheck", {boardNo:postNo, pswd:inputPswd}).then(resp => {
                if(resp.data=="success") {
                    inquiryPostDetail(postNo);
                }else {
                    failAlert();
                }
            })
        })
    }
}
```

&nbsp;&nbsp;사용자가 문의글을 클릭했을 때, 해당 글이 비공개(`pswdYn == "Y"`)일 경우 비밀번호 입력 모달을 띄우고, 입력값을 `/pswdCheck` API로 전송하여 비밀번호를 검증한 뒤 일치 시 상세 페이지로 이동하도록 처리하였습니다.  **Axios POST 요청**으로 데이터를 전송하며, 성공 시 `inquiryPostDetail()` 함수를 통해 해당 게시글로 이동하고, 실패 시 알림창을 출력합니다.<br>
<br>

```java
@ResponseBody
@PostMapping("/pswdCheck")
public String pswdCheck(@RequestBody Map<String, Object> data) {
    BoardPostVO boardPostVO = this.inquiryPostService.getInquiryDetail((int)data.get("boardNo"));
    if(boardPostVO.getInquiryPostVO().getInqPswd().equals(data.get("pswd"))) { 
        return "success";
    }else {
        return "fail";
    }
}
```
&nbsp;&nbsp;프론트에서 전달된 게시글 번호를 기반으로 게시글 정보를 조회하고, **입력된 비밀번호와 DB에 저장된 비밀번호가 일치하는지 비교**하여 `"success"` 또는 `"fail"` 문자열을 반환합니다. 비밀번호가 일치하면 상세 페이지로 이동할 수 있도록 프론트와 연동되어 작동합니다.  
<br>

---

### 문의 글 관리 화면

<a name="ajax"></a>

**1) 비동기 기반 게시글 목록 조회 및 커스텀 페이지네이션 구현**  

![주요화면](/assets/img/pro/ems/my-part/문의글관리자화면.gif "문의글관리자화면")
<center><small>문의글 관리자 화면.gif</small></center>  
<br>

```javascript
// 처음 렌더링 될 때 실행
fn_search(1);

function fn_search(page) {

    const inqType = document.getElementById("inqType");
    const isMember = document.getElementById("isMember");
    const ansYn = document.getElementById("ansYn");
    const bbsDelYn = document.getElementById("bbsDelYn");
    const isSecret = document.getElementById("isSecret");
    const inqWriter = document.getElementById("inqWriter");
    const startDate = document.getElementById("startDate");
    const endDate = document.getElementById("endDate");
    const mode = document.getElementById("mode");
    const keyword = document.getElementById("keyword");

    const params = {
        isMember : isMember.value,
        ansYn : ansYn.value,
        bbsDelYn : bbsDelYn.value,
        isSecret : isSecret.value,
        inqTypeNo : inqType.value,
        inqWriter : inqWriter.value,
        startDate : startDate.value,
        endDate : endDate.value,
        mode : mode.value,
        keyword : keyword.value, 
        page : page,
        blockSize : blockSize,
        start : (page - 1) * blockSize + 1,
        end : page * 10
    }

    axios.get("/admin/inquiryPost/getListAjax", { params }).then(resp => {
        const { content, currentPage, totalPages, startPage, endPage } = resp.data;
        renderTable(content);
        renderPagination({currentPage, totalPages, startPage, endPage});
    })
}
```
&nbsp;&nbsp;사용자 경험 향상을 위해 **Axios를 활용한 비동기 요청 기반의 게시글 목록 조회 기능**을 구현하였으며, 클라이언트 측에서 페이지 번호에 따라 `start`, `end` 값을 동적으로 계산하여 서버에 전달하도록 설계하였습니다.  

&nbsp;&nbsp;서버에서는 요청 파라미터를 바탕으로 전체 데이터 수에 따른 페이지네이션 메타데이터(현재 페이지, 전체 페이지 수, 시작/끝 페이지 등)를 계산한 후 JSON 형식으로 응답하며,
프론트엔드는 해당 응답을 기반으로 목록 렌더링 함수 (`renderTable`) 및 페이징 UI (`renderPagination`)를 동적으로 호출하여 화면을 구성하도록 구현하였습니다.  

&nbsp;&nbsp;이 과정에서 **JSP 기반의 서버 템플릿 방식과 JavaScript 기반의 클라이언트 렌더링을 유기적으로 연결**해, 화면 전환 없이도 필터링, 검색, 페이지 이동 등이 가능한 사용자 친화적인 인터페이스를 구축하였습니다.  
<br>

<a name="crud"></a>

**2) 문의글 / 답글 관리**  

![주요화면](/assets/img/pro/ems/my-part/답변등록.gif "답변등록화면")
<center><small>답변 등록 화면.gif</small></center>  
<br>

<a name="download"></a>

**3) 첨부파일 다운로드**  

![주요화면](/assets/img/pro/ems/my-part/첨부파일다운로드.gif "첨부파일다운로드")
<center><small>첨부파일 다운로드.gif</small></center>  
<br>

```javascript
function downloadImage() {
    const selected = document.querySelectorAll(".imageCheck:checked");
    
    if (selected.length === 0) {
        alert("다운로드할 이미지를 선택해주세요!");
        return;
    }
    
    selected.forEach((checkbox, index) => {
        const imgSrc = checkbox.getAttribute("data-src");
        const link = document.createElement("a");
        const imgName = checkbox.getAttribute("data-img-name");
        link.href = imgSrc;
        link.download = imgName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });
    
}
```

&nbsp;&nbsp;**JavaScript 기반 이미지 다중 다운로드 기능을 구현하여, 관리자가 게시물에 첨부된 이미지를 선택적으로 내려받을 수 있도록 구성하였습니다.**
체크박스에 선택된 이미지 요소에서 `data-src`, `data-img-name` 속성을 추출한 뒤, `<a>` 태그를 JS에서 동적으로 생성하고, `download` 속성을 활용하여 클라이언트 단에서 반복적으로 다운로드 이벤트를 발생시키는 방식으로 구현하였습니다.  

&nbsp;&nbsp;별도의 서버 요청 없이 **브라우저 내에서 즉시 다운로드가 수행되는 UX 최적화 기능**으로, 사용자 편의성과 처리 효율성을 동시에 확보하였습니다.  
<br>

---

### Full Calendar 기반 일정 관리 기능 구현

<a name="calenear-crud">

**1) 사내 일정 통합 관리**  

&nbsp;&nbsp;**부서 및 개인 일정을 통합 관리할 수 있는 사내 캘린더**를 구현하였습니다.  
  
&nbsp;&nbsp;일정 데이터는 아래와 같은 구조의 테이블에 저장되며, `사원 번호(EMP_NO)` 또는 `부서 번호(DEPT_NO)`의 존재 여부에 따라 **개인 일정** 또는 **부서 일정**으로 분류됩니다.

| 컬럼명                    | 데이터 타입         | 제약 조건        | 설명             |
| ---------------------- | -------------- | ------------ | ------------------- |
| `EMPLOYEE_SCHEDULE_NO` | NUMBER         | PK, NOT NULL | 일정 고유 번호 (기본 키)     |
| `START_DATE`           | VARCHAR2(10)   |              | 일정 시작일 (YYYY-MM-DD) |
| `END_DATE`             | VARCHAR2(10)   |              | 일정 종료일 (YYYY-MM-DD) |
| `DEPT_NO`              | NUMBER         |              | 부서 번호 (있으면 부서 일정)|
| `EMP_NO`               | NUMBER         |              | 사원 번호 (있으면 개인 일정)|
| `BACKGROUND_COLOR`     | VARCHAR2(20)   |              | 일정 배경 색상 |
| `TEXT_COLOR`           | VARCHAR2(20)   |              | 글자 색상               |
| `BORDER_COLOR`         | VARCHAR2(20)   |              | 테두리 색상              |
| `DEL_YN`               | VARCHAR2(1)    | DEFAULT 'N'  | 삭제 여부      |
| `TITLE`                | VARCHAR2(1000) |              | 일정 제목               |
| `DESCRIPTION`          | VARCHAR2(3000) |              | 일정 상세 설명            |

&nbsp;&nbsp;**개인 및 부서 일정을 하나의 테이블로 관리**함으로써 불필요한 테이블 분리를 방지하고, 일정을 조회하거나 출력할 때 통합된 구조로 효율적인 처리가 가능하도록 설계하였습니다.  
<br>

![주요화면](/assets/img/pro/ems/my-part/풀캘린더.gif "풀캘린더")
<center><small>사내 캘린더.gif</small></center>  
<br>

```javascript
customButtons: {
  myCustomButton1: {
    text: '개인',
    click: () => {
      const filtered = schedules.filter(s => s.type === 'persnal');
      calendar.getEventSources().forEach(s => s.remove());
      calendar.addEventSource(filtered);
    }
  },
  myCustomButton2: {
    text: '부서',
    click: () => {
      const filtered = schedules.filter(s => s.type === 'department');
      calendar.getEventSources().forEach(s => s.remove());
      calendar.addEventSource(filtered);
    }
  },
  myCustomButton3: {
    text: '전체',
    click: () => {
      calendar.getEventSources().forEach(s => s.remove());
      calendar.addEventSource(schedules);
    }
  }
},
eventClick: function(info) {
  const event = info.event;
  document.querySelector("input[name=title]").value = event.title;
  document.querySelector("textarea[name=description]").value = event.extendedProps.description;
  
  if (event.extendedProps.type === "department" && userRole !== "이사") {
    // 부서 일정은 이사만 수정 가능
    hideButtons();
  }
  scheduleOpen();
}
```

&nbsp;&nbsp;프론트엔드는 **FullCalendar.js**를 활용하여 일정 등록, 조회, 수정, 삭제(CRUD)를 지원하며, 백엔드는 Oracle의 `EMPLOYEE_SCHEDULE` 테이블과 연동하였습니다.

&nbsp;&nbsp;캘린더 상단에는 FullCalendar의 `customButtons` 기능을 사용해 **'전체 / 부서 / 개인 일정' 필터 버튼**을 추가하였고, 각 일정은 `type` 속성(`department`, `personal`)에 따라 실시간 필터링되도록 구현했습니다.

&nbsp;&nbsp;일정 클릭 시 `eventClick` 이벤트를 통해 **모달창에 상세 정보가 표시**되며, `userRole` 값에 따라 수정 및 삭제 버튼의 노출을 **권한 기반으로 동적으로 제어**합니다.

&nbsp;&nbsp;사용자는 일정 등록 시 **색상 설정, 제목·내용 입력, 날짜 범위 지정**이 가능하며, 관리자는 부서 일정을 전체적으로 확인하고 조정할 수 있어, **시각성과 편의성이 높은 웹 기반 일정 관리 기능**을 완성하였습니다.  
<br>

---

> ## 프로젝트 평가

## - 문제 해결 과정

 **1. Spring Security 다중 로그인 흐름 커스터마이징**  
&nbsp;&nbsp;Spring Security의 기본 개념과 주요 컴포넌트들에 대한 이론은 학습했지만, 프로젝트에 실제 적용하는 과정에서는 이해한 개념을 구조적으로 연결하는 데 어려움이 있었습니다. 특히, 관리자 / 직원 / 일반 회원의 로그인 경로와 권한을 분리해 관리하려 할 때, 하나의 `SecurityFilterChain`으로 모든 경로를 처리하면서 **권한 충돌이나 리다이렉션 오류**가 자주 발생했습니다.  
  
&nbsp;&nbsp;예를 들어, 일반 사용자가 `/admin/**` 페이지에 접근하거나, 관리자가 로그인했음에도 사용자 페이지로 리다이렉트되는 등 흐름이 꼬이는 현상이 반복되었습니다.  
    
&nbsp;&nbsp;이런 문제를 해결하기 위해 **Spring Security 공식 문서**와 실무 예제 블로그, GitHub 코드를 참고하며 `HttpSecurity`, `SecurityFilterChain`, `@Order`, `securityMatcher` 등 보안 필터의 작동 원리를 **실제 흐름 중심으로 다시 학습**했습니다. 단순히 기능을 외우는 것이 아니라, 요청이 어떻게 필터를 거쳐 처리되는지에 초점을 맞춰 개념을 정리했습니다.  
  
&nbsp;&nbsp;그 결과, 각 경로(`/admin/**`, `/emp/**` 등)에 대해 별도의 `SecurityFilterChain`을 정의하고, `@Order`를 활용하여 요청 순서에 따라 보안 흐름을 분리할 수 있다는 구조를 이해하게 되었습니다.  
<br>

```java
@Bean
@Order(1)
public SecurityFilterChain adminSecurity(HttpSecurity http) throws Exception {
    return http
        .securityMatcher("/admin/**")
        .authorizeHttpRequests(auth -> auth
            .requestMatchers("/admin/login").anonymous()
            .requestMatchers("/admin/**").hasRole("ADMIN")
        )
        .formLogin(form -> form
            .loginPage("/admin/login")
            .successHandler(customLoginSuccessHandler))
        .build();
}
```
&nbsp;&nbsp;또한 `AuthenticationSuccessHandler`를 커스터마이징하여 로그인 성공 시 권한에 따라 사용자에게 **적절한 홈화면으로 리다이렉트되도록 설정**했습니다.

```java
switch (redirectURL) {
  case "/admin/login" -> redirectURL = "/admin/home";
  case "/emp/login" -> redirectURL = "/emp/home";
  default -> redirectURL = "/oho"; // 일반 사용자 홈
}
```
&nbsp;&nbsp;결과적으로 각 사용자 유형에 맞는 보안 흐름을 안정적으로 구현할 수 있었고,  
Spring Security의 흐름을 **이론 → 구조 이해 → 실전 커스터마이징**으로 연결해 나간 중요한 경험이 되었습니다.

<br>

**2. 카카오 로그인 → OAuth2 전환**

&nbsp;&nbsp;초기에는 **카카오 로그인 API를 직접 호출하는 방식으로 구현을 시도**했지만, 리다이렉트 처리, 토큰 관리, 사용자 정보 요청 등 복잡한 흐름을 직접 처리해야 하는 점에서 **유지보수에 어려움이 있음**을 느꼈습니다.  

&nbsp;&nbsp;이후 **Spring Security의** `OAuth2 Client` **기능을 조사**하였고, 이를 활용하면 인증 흐름과 토큰 처리, 사용자 정보 매핑을 표준 방식으로 처리할 수 있다는 점에서 구조적 이점을 확인하였습니다.  

&nbsp;&nbsp;이에 `spring.security.oauth2.client.registration` 설정을 통해 **카카오 로그인을 OAuth2 방식으로 전환**하였고, `DefaultOAuth2UserService`를 커스터마이징하여 사용자 정보를 우리 시스템의 `User` 객체와 연결하는 로직으로 재구성하였습니다.  

&nbsp;&nbsp;**결과적으로 인증 흐름이 단순화되고, 유지보수성과 확장성(Google, Naver 등 추가 가능성)도 확보**할 수 있게 되었습니다.  

<br>

**3. 비동기 요소의 이벤트 미동작**

&nbsp;&nbsp;이미지 다운로드 기능 구현 중, **비동기 로딩된 DOM 요소에 클릭 이벤트가 동작하지 않는 문제를 경험**했습니다.  

&nbsp;&nbsp;문의글 상세 화면에서는 첨부된 이미지를 체크박스로 선택하고 다운로드할 수 있도록 JavaScript 기반 기능을 구현하고 있었는데, 처음 로딩된 정적 요소에서는 이벤트가 정상 작동하던 반면, **Ajax 요청을 통해 렌더링된 이미지 영역에서는** querySelectorAll()로 선택한 .imageCheck 요소에 forEach()로 바인딩한 **클릭 이벤트가 전혀 반응하지 않았습니다.**  

&nbsp;&nbsp;처음에는 스크립트 오류나 클래스명 오타를 의심했지만, console로 로그를 찍어보며 확인한 결과 **문제는 'DOM 렌더링 시점'**에 있음을 파악했습니다.  

&nbsp;&nbsp;즉, **addEventListener()가 실행될 당시 해당 요소가 DOM에 존재하지 않았기 때문에 이벤트가 바인딩되지 않았던 것이었습니다.**  

&nbsp;&nbsp;이 문제를 해결하기 위해, 이벤트 위임 방식이나 MutationObserver도 고려했으나, 구현 구조상 단순한 반복 바인딩이 더 적합하다고 판단하여, DOMContentLoaded 이후에 Ajax로 로딩된 DOM 요소들을 다시 탐색한 뒤 **document.querySelectorAll(".imageCheck:checked")로 이벤트를 재바인딩**하는 방식으로 구현을 수정했습니다.  

&nbsp;&nbsp;이 과정을 통해 클라이언트 단에서 발생하는 **렌더링 시점 문제를 경험하고, 비동기 요소와 이벤트 바인딩 간의 흐름을 이해**하고 디버깅하는 역량을 키울 수 있었습니다.

```javascript
// 코드 스니펫
const selected = document.querySelectorAll(".imageCheck:checked");
selected.forEach((checkbox) => {
  const link = document.createElement("a");
  link.href = checkbox.dataset.src;
  link.download = checkbox.dataset.imgName;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
});
```

<br>

---

## - 성과 및 회고  

🔹 **협업**  

&nbsp;&nbsp;비전공자와 전공자가 함께한 팀 프로젝트였기에, 각자의 이해도와 속도 차이를 조율하는 것이 쉽지만은 않았습니다.  
그 과정에서 단순한 역할 분담이 아니라, 서로의 상황을 이해하고 도와가며 맞춰가는 협업의 본질을 배울 수 있었습니다.  

&nbsp;회의록 작성, 일정 관리, 진행 상황 공유 등 소통의 기본부터 지키려 노력했고, **혼자보다 함께할 때 더 나은 결과가 나온다는 것**을 몸소 느낄 수 있던 시간이었습니다.

🔹 **PL의 역할**  

&nbsp;&nbsp;PL로서 모든 팀원의 의견을 다 수용하고 싶었지만, 때론 우선순위에 따라 과감히 결정을 내려야 했고, 그런 점들이 아쉬움으로 남습니다.  
  
&nbsp;&nbsp;그럼에도 불구하고 제가 팀원들을 믿은 만큼, 팀원들도 저를 믿고 따라와 주었고, **서로에 대한 신뢰 덕분에 이 프로젝트를 끝까지 웃으며 마무리할 수 있었습니다.**

🔹 **기술적인 성장**  

&nbsp;&nbsp;이번 프로젝트는 프레임워크에 대한 개념 이해부터 직접 구현까지 이론과 실습을 오가며 기술을 내 것으로 만든 시간이었습니다.  

&nbsp;&nbsp;Spring Security를 처음 실전 프로젝트에 적용해보며 인증과 인가의 흐름을 직접 구성했고, 권한별 분기 처리와 보안 필터 커스터마이징 과정을 통해 보안 프레임워크에 대한 이해가 크게 향상되었습니다.  

&nbsp;&nbsp;FullCalendar를 활용해 일정 관리 UI를 구현하면서, 데이터 바인딩, 역할 기반 필터링, 이벤트 처리 등 프론트엔드와 백엔드의 연결 구조를 처음부터 끝까지 직접 설계해보았습니다.  

&nbsp;&nbsp;게시판은 Oracle의 계층형 쿼리(CONNECT BY)를 이용해 트리 형태로 구성하였고, 비동기 방식으로 목록을 불러온 뒤 이벤트 바인딩 이슈를 해결하며 DOM 제어의 흐름도 자연스럽게 익히게 되었습니다.

&nbsp;&nbsp;그 외에도 Google 번역 API, 파일 업로드 및 다운로드 기능, 다국어 처리 등 웹 서비스를 구성하는 다양한 기능을 직접 구현하며 스스로 많은 벽을 넘어설 수 있었습니다.

<br>

---


## - 향후 개선 방향

🔹 **인덱스 설계 반영**  
&nbsp;&nbsp;관리자 화면에서 조건별로 게시글 목록을 조회하는 기능을 구현하면서, **인덱스를 활용한 성능 최적화의 중요성**을 뒤늦게 체감했습니다.  
당시에는 정렬과 WHERE 조건에만 집중해 구현했지만, **실제 대용량 데이터를 다룰 경우, 적절한 인덱스 없이 조건 검색만으로는 성능이 급격히 저하된다는 점**을 경험을 통해 알게 되었습니다.  

&nbsp;&nbsp;다음 프로젝트에서는 초기 설계 단계부터 데이터 조회 방식에 맞춰 인덱스 전략을 함께 수립하고, 실**질적인 성능 개선을 고려한 DB 구조를 기획하고 싶습니다.**  
<br>

🔹 **번역 기능의 동적 처리**  
&nbsp;&nbsp;Google Cloud Translation API를 활용해 게시글 자동 번역 기능을 구현했지만, 사용자의 브라우저 언어 설정 또는 시스템 로케일에 따라 번역 버튼을 동적으로 노출하거나, 번역 대상 언어를 자동으로 지정하는 부분까지는 구현하지 못해 아쉬움이 남습니다.  

&nbsp;&nbsp;**향후에는 navigator.language 또는 Spring의 LocaleResolver를 활용해 사용자의 언어 설정을 기준으로 번역 버튼을 노출**하고, **번역 대상 언어를 자동 지정하여 더 직관적이고 사용자 친화적인 번역 기능을 제공**하고 싶습니다.  
<br>

🔹 **서버 구조의 명확한 분리**  
&nbsp;&nbsp;이번 프로젝트에서는 관리자·직원·일반 사용자의 요청을 모두 하나의 서버에서 처리하며, Spring Security의 필터 설정과 경로 분기 로직을 분리하는 데에 복잡도와 유지보수 비용이 높아지는 문제가 있었습니다.  

&nbsp;&nbsp;특히 권한별 접근 제어와 화면 이동 흐름을 구성할 때 많은 조건 분기 로직이 필요했고, 보안 필터를 세분화하는 데에도 시간이 많이 소요되었습니다.  

&nbsp;&nbsp;다음 프로젝트에서는 **사용자와 내부 시스템(관리자, 직원)을 아예 다른 서버 또는 모듈 단위로 분리해, 더 구조화된 인증·인가 체계를 설계**해보고 싶습니다. 이를 통해 **유지보수성과 보안 측면 모두에서 개선된 시스템을 구축할 수 있을 것이라 생각합니다.**
<br><br>